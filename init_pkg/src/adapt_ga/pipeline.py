import rospy 
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion
import math
import tf

from ga import * 
from strategy import * 


# maybe helpful function 
def get_current_heading():
    # example, prob won't work as is 
    listener = tf.TransformListener()
    listener.waitForTransform("/base_link", "/odom", rospy.Time(0), rospy.Duration(4.0))
    (trans, rot) = listener.lookupTransform("/base_link", "/odom", rospy.Time(0))
    
    # Convert quaternion to euler angles
    _, _, yaw = euler_from_quaternion(rot)
    return yaw


# 1. each agent gets randomly assigned a chromosome 
ga_rob = GA()
ga_rob.create_individual_genotype()

ga_rob_2 = GA()
ga_rob_2.create_individual_genotype()

print(f'example genotype generated: {ga_rob.curr_genotype}')
processed_chromosome = ga_rob.process_chromosome(ga_rob.curr_genotype)
print(f'example of processed chromosome: {processed_chromosome}') # returns forward_speed, energy_cost, energy_per_item, observations_threshold

st = Strategy(reward=10, penalty=2, obs_thres=5, step_size=5)
st.update_from_chrom(processed_chromosome)
print(f'updated parameters relevant to foraging strategy employed')

strategy_generated = st.resample(curr_dir=0.00)
print(f'example stategy generated (its a list of orientations): {strategy_generated}')


# 2. Throughout foraging task 
# this will return error bc I didn't import and use the class .. but this showcases how this could be used 
time_into_sim = 0
prev_time = rospy.get_time() 
found_object = False 
curr_strat_complete = False 
num_collected = 0 
num_collisions = 0 
collision = False 
curr_strat_index = 0 

if __name__ == "__main__": 
    rospy.init_node("parser")
    parser = DistanceParser('/dev/serial/by-id/usb-1aB6_USb2.0-Serial-if00-port0')

    cmd_vel_publisher = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
    # publish updated speed to cmd_vel using ga chrom 
    cmd_vel = Twist()
    # Set linear and angular velocities
    cmd_vel.linear.x = st.step_size  # Move forward at 0.5 m/s
    cmd_vel.angular.z = 0.0  # No rotation (this will get updated based on orientation you want ..)
    # Publish the message
    cmd_vel_publisher.publish(cmd_vel)
    
    contact_pub = rospy.Publisher('/contact', Bool, queue_size=10)

    # note: might need topic to detect collision (if any should happen)

    while not rospy.is_shutdown():

        dist, contact = parser.parse()
        current_heading = get_current_heading()

        # ---- (TIME-BASED UPDATES) -
        # state: after each second has elapsed, update time into generation and time spent using current strategy 
        if rospy.get_time() - prev_time == 1: 
            prev_time = rospy.get_time()
            time_into_sim += 1  
    
        # state: after generation has completed (happens in 30 sec increments, update each agent's chromosome)
        if time_into_sim % 30: 
            # update agent chromosome 
            new_chr = ga_rob.reproduce()
            processed_chromosome = ga_rob.process_chromosome(ga_rob.curr_genotype)
            st.update_from_chrom(processed_chromosome)


        # ---- (EVENT-BASED UPDATES) ------
        # state: upon contact with each other, agents exchange chromosome info 
            # if one has higher fitness than highest encountered for that agent, that chromsome and corresponding fitness is stored
        if contact: 
            # you would need the chromosome of other agent (in list form) or other agent object and their corresponding fitness
            ga_rob.update_best_encountered(r2=ga_rob_2, fitness = 0)

        # if in collision state, update fitness 
        if collision: 
            num_collisions += 1 
            ga_rob.update_fitness(num_collected, num_collisions)

        # state: after successful collection, update prob distrib + energy value 
        if found_object: # this would be based on pos of agent and predefined pos of objects 
            st.collect()
            num_collected += 1 
            ga_rob.update_fitness(num_collected, num_collisions)

        # general exploration strategy, can be refined, but will use list of orientations to 
        # determine where robot should move towards 
        # state: after strategy complete, update prob distrib + reset energy value to be the reward param 
        if not found_object: # not in homing state, continue with general exploration strategy, generated by strategy class 
            if curr_strat_index <=4: 
                strategy_generated = st.resample()
                curr_strat_index = 0 
                target_heading = strategy_generated[curr_strat_index]

            else: 
                curr_strat_index += 1 
                target_heading = strategy_generated[curr_strat_index]
                # if not use strategy outputted to determine subsequent orientation .. 
            heading_diff = (heading_diff + math.pi) % (2 * math.pi) - math.pi
            if abs(heading_diff) > 0.1:  # Threshold to stop turning
                cmd_vel.angular.z = 0.5 if heading_diff > 0 else -0.5
            else: # move forward (can be constrained to some time limit)
                cmd_vel.linear.x = st.step_size  # Move forward at 0.5 m/s
                cmd_vel.angular.z = 0.0  # No rotation (this will get updated based on orientation you want ..)

            # Publish the command
            cmd_vel_publisher.publish(cmd_vel)


        # 3. After successful collection, return back to center + continue foraging task .. 
        if found_object: 
            pass # move back to the center of the environment 

        rospy.sleep(0.005)